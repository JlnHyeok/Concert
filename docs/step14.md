# 14. 대기열 시스템 설계

대기열 시스템은 사용자의 요청을 효율적으로 관리하고 처리하기 위해 Redis의 **ZSET(정렬된 집합)**과 **HASH(해시 자료 구조)**를 활용하여 설계되었습니다. 각각의 Redis 자료 구조는 대기열 요구사항에 맞춰 효율성을 극대화하는 방식으로 사용되었습니다.

---

## 14.1 Redis 자료 구조 활용

### 1. ZSET (정렬된 집합)

**ZSET**은 대기열 순서를 관리하는 데 사용됩니다.
요청이 들어오면 ZSET에 `queueKey` (UUID 기반 고유 키)를 추가하며, 요청 생성 시각을 `score`로 설정하여 정렬 기준으로 사용합니다.
이를 통해 대기열 내의 항목을 자동으로 시간 순으로 정렬할 수 있어, 가장 오래된 요청부터 순차적으로 처리하는 것이 가능합니다.

**ZSET의 주요 이점:**

- **자동 정렬**: 삽입된 데이터가 자동으로 정렬되므로 대기열 순서 확인이 빠릅니다.
- **효율적인 검색 및 삭제**: Redis의 `zrange`와 같은 명령어로 빠르게 필요한 범위의 데이터를 검색할 수 있어, 효율적인 대기열 조회가 가능합니다.

---

### 2. HASH (해시 자료 구조)

**HASH**는 각 대기열 항목의 상세 정보를 저장하는 데 사용됩니다.
`queueKey`를 기준으로 각 대기열 항목에 대한 UUID, `status`(WAITING, PROCESSING, EXPIRED 등 상태 정보), `createdAt`, `activatedAt`, `expireAt`와 같은 정보를 저장하여 관리합니다.
이를 통해 특정 항목에 대한 정보를 빠르게 조회하고 상태를 변경할 수 있습니다.

**HASH의 주요 이점:**

- **데이터 구조화**: 하나의 키에 여러 속성을 저장할 수 있어, 항목의 상태와 메타데이터를 효율적으로 관리할 수 있습니다.
- **빠른 접근**: 특정 `queueKey`에 대해 필요한 정보에 바로 접근할 수 있어 데이터 조회와 업데이트가 빠릅니다.

---

## 14.2 대기열 처리 흐름

### 1. 토큰 생성 및 대기열 등록

- 사용자의 요청이 접수되면 UUID를 생성하여 ZSET에 추가하고, 요청 시간(`score`)을 설정합니다.
- 해당 UUID를 기준으로 HASH에 관련된 세부 정보를 저장합니다.

### 2. 즉시 처리 가능 여부 확인

- 현재 대기열의 `PROCESSING` 상태 항목 수를 확인하여, 처리 가능한 여유 슬롯이 있으면 대기 중인 항목을 즉시 활성화(`PROCESSING` 상태로 변경)합니다.

### 3. 주기적 대기열 상태 업데이트

- Cron을 이용하여 일정 주기마다 ZSET을 순회하며 만료된 `PROCESSING` 항목을 제거하고, 여유 슬롯이 있을 경우 대기 중인 항목을 `PROCESSING` 상태로 전환합니다.
- HASH에 `expireAt` 정보를 업데이트하여 만료 시간을 관리합니다.

### 4. 대기열 상태 조회

- 요청한 토큰을 기반으로 HASH에서 현재 상태를 확인하고, ZSET을 이용해 대기 번호와 예상 대기 시간을 계산하여 반환합니다.

---

---

## 14.3 우려 사항: Redis 장애 시 데이터 유실 가능성

- Redis는 메모리 기반 데이터 저장소이므로, 장애가 발생할 경우 대기열 데이터가 유실될 가능성이 있습니다. 이는 중요한 대기열 데이터가 손실되면 사용자 요청이 정상적으로 처리되지 않거나, 순서가 꼬일 위험이 있습니다.

### 해결 방안: 데이터 영속성 확보 및 복구 메커니즘 도입

- Redis의 **RDB 스냅샷** 및 **AOF (Append Only File)** 기능을 활성화하여 데이터 영속성을 강화할 수 있습니다. 이를 통해 Redis가 비정상 종료되어도 최근 상태를 복구할 수 있습니다.
- 추가적으로, 주기적으로 Redis 대기열 데이터를 **RDB에 백업**하거나, Redis Sentinel 및 Redis Cluster를 활용해 장애 발생 시 자동으로 대기열 상태를 다른 인스턴스에서 복구하도록 설정할 수 있습니다.
- 장애 발생에 대비하여 중요한 대기열 데이터를 RDB에 복제하는 방안을 추가함으로써 데이터 유실 가능성을 최소화할 수 있습니다.

#### redis.conf 예시

```conf
### RDB와 AOF 모두 활성화하여 영속성 강화
### RDB는 빠른 복구를 위한 스냅샷 저장, AOF는 로그를 통해 트랜잭션을 기록
# RDB (Redis Database) 스냅샷 설정
# 매 60초마다 10000개 이상의 key가 변경될 경우 스냅샷 생성
save 60 10000

# AOF (Append Only File) 활성화
# 모든 쓰기 작업을 AOF에 기록하여 데이터 영속성을 강화
appendonly yes

# AOF 동기화 옵션
# 매 쓰기마다 동기화: 가장 안전하지만 성능에 영향
# appendfsync always  # 이 옵션은 각 쓰기마다 AOF에 동기화하여 가장 안전한 옵션이지만 성능에 큰 영향을 미침
appendfsync everysec   # 1초마다 AOF를 디스크에 동기화
# OS가 알아서 동기화하도록 설정: 성능은 좋으나 데이터 유실 위험
# appendfsync no  # 성능이 가장 좋지만, Redis가 비정상 종료될 경우 데이터 유실 위험이 있음

# AOF 파일 압축을 활성화 (디스크 공간 절약)
no-appendfsync-on-rewrite yes

# 장애 복구 및 내결함성 설정

# Redis Sentinel 설정 (복제본 감시 및 장애 복구)
# Redis Sentinel은 마스터 Redis 인스턴스를 감시하고 장애가 발생했을 때 자동으로 복제본을 마스터로 승격시킴
# sentinel.conf 파일을 별도로 작성하고 아래와 같이 설정합니다.
# sentinel monitor mymaster 127.0.0.1 6379 2

# Redis Cluster 설정 (자동 데이터 분할 및 복구)
# Redis 클러스터 환경에서 여러 Redis 인스턴스가 자동으로 데이터를 분할하여 저장하고 장애 복구를 수행함
# cluster-enabled yes
# cluster-config-file nodes.conf

# Redis 클러스터의 노드에 대해 자동 복구를 위한 설정
cluster-require-full-coverage no  # 클러스터에서 일부 슬롯이 비어 있더라도 동작할 수 있도록 설정
```

## 설계 요약

이 설계를 통해 Redis의 ZSET과 HASH의 장점을 활용하여 대기열을 효율적으로 관리하고, 대기 시간을 최소화하며 안정적으로 사용자 요청을 처리할 수 있도록 구성하였습니다.
